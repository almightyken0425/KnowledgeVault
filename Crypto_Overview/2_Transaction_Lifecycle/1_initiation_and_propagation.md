# Initiation & Propagation 發起與傳播

這是交易旅程的起點。一切始於使用者意圖發起一筆價值轉移。

---

## Creation & Signing 建立與簽署

當 Alice 想要轉帳給 Bob 時，她的錢包軟體會建立一個包含關鍵資訊的資料結構：

- **輸入 Input:** 資金來源，即 Alice 之前的某筆收款紀錄。
- **輸出 Output:** 資金去向，即 Bob 的錢包地址與轉帳金額。
- **手續費 Fee:** 願意支付給礦工的費用。

接著，Alice 必須使用她的私鑰對這個資料結構進行數位簽章。這就像是在支票上簽名一樣，證明這筆交易確實經過她的授權。

---

## Technical Submission 提交細節

從技術實作的角度來看，發送交易到區塊鏈網路本質上就是發送一個 HTTP POST 請求。

- **本質:** 對節點發送標準的 JSON-RPC 請求。
- **差異:** 差別在於請求內容 Payload 的資料結構。
    - **一般 Web API:** 通常傳遞易讀的 JSON 物件，例如 `{ "from": "Alice", "to": "Bob", "amount": 10 }`。
    - **區塊鏈 API:** 傳遞的是經過序列化與數位簽章的十六進位字串，例如 `{ "param": "020000..." }`。這串資料中不包含任何明文的身份資訊。

### 請求內容 The Payload

客戶端傳送的是一串 **序列化並簽名過的十六進位字串 Hex String**。這確保了即使請求被中間人擷取，也無法竄改交易內容，因為任何變動都會導致簽章驗證失敗。

- **Method:** `sendrawtransaction` 這是比特幣核心標準的 RPC 方法。
- **Params:** `["0200000001df8..."]` 這串長長的亂碼就是 **Signed Raw Transaction**。

### 封包結構包含什麼

該十六進位字串解開後，包含了以下核心欄位：

- **Metadata:**
    - `Version`: 交易格式版本。
    - `Locktime`: 最早可被打包的時間 通常設為 0 即立即。
- **Inputs 輸入列表:** 告訴網路錢從哪裡來。
    - `TxID`: 上一筆交易的 ID。
    - `Vout`: 上一筆交易的第幾個輸出。
    - `ScriptSig`: **解鎖腳本**，這裡面就包含發送者的 **數位簽章** 與 **公鑰**。
- **Outputs 輸出列表:** 告訴網路錢要去哪裡。
    - `Value`: 轉帳金額 Satoshi。
    - `ScriptPubKey`: **鎖定腳本**，這裡面包含了接收者的 **地址條件**。

### 如何解開 How to Deserialize

這不是加密，而是 **編碼 Encoding**。所有的節點與錢包軟體都遵循同一套公開的序列化協議 Serialization Protocol。

- **過程:** 節點讀取 Hex String，並依照協議逐位元組讀取。例如，前 4 個 Bytes 代表版本號，接下來的一個 Byte 代表輸入數量，依此類推。
- **工具:** 開發者通常不需要自行撰寫解析器，而是使用標準函式庫 如 `bitcoinjs-lib` 或 `web3.js` 來自動將 Hex String 轉換回易讀的物件結構。

### 觀念釐清：為何沒有區塊頭資訊

你可能會疑惑，為什麼這裡面沒有 `Previous Block Hash` 或 `Merkle Root` 這些欄位 參考 Data Structures。

- **交易 vs 區塊:**
    - **交易 (Transaction):** 這是使用者發送的內容，就像是一張支票。它只包含「誰轉給誰」與「金額」。此時它還漂浮在網路上，尚未被寫入帳本。
    - **區塊 (Block):** 這是礦工打包後的產物，就像是銀行的結算帳本。礦工把幾千筆交易 支票 裝訂在一起，並加上封面 Block Header。
- **時間差:** 當你發送 `sendrawtransaction` 時，這筆交易還在記憶體池 Mempool 中排隊。它還不知道自己最終會被裝進哪一個區塊，因此自然不具備區塊的相關欄位。

### 如何找到 IP Address

客戶端需要知道將請求發送給哪個 IP 地址：

- **DNS Seeds 種子節點:**
    - 這是去中心化網路最底層的發現機制。程式碼中內建了一些 DNS 域名 如 `seed.bitcoin.sipa.be`。
    - 客戶端啟動時查詢這些域名，以獲取當前在線的活躍節點 IP 列表。
- **Infra Providers 基礎設施服務商:**
    - 開發者常用的第三方服務，如 Infura, Alchemy, QuickNode。
    - 這些服務商維護大量節點並提供統一的 API Endpoint，簡化了開發流程。這也是 MetaMask 等錢包預設的連線方式。
- **Localhost 本地節點:**
    - 使用者自行架設全節點，並將請求發送給本地地址 `127.0.0.1:8332`。
    - 這是最安全且最具隱私的方式，完全不依賴第三方。

---

## Broadcast 廣播

當節點透過 RPC 介面收到這串 Hex String 後，它不會照單全收，而是會進行驗證：

- **簽章驗證:** 解開 `ScriptSig`，確認簽章是否與公鑰匹配。
- **餘額檢查:** 檢查 `TxID` 指向的資金是否真的存在且未被花費過 UTXO。

一旦檢查通過，該節點就會將這筆交易透過 P2P 協定轉發給它的鄰居節點。透過這種八卦協定 Gossip Protocol，交易資訊會在極短的幾秒鐘內擴散到全球。

## The Mempool 記憶體池

通過驗證但尚未被打包進區塊的交易，會暫時停留在每個節點的暫存區中，這個區域被稱為記憶體池 Mempool。

- **等待室:** 可以將記憶體池想像成一個巨大的候機室，所有的交易都在這裡等待搭上下一班名為區塊的列車。
- **優先順序:** 候機室通常是擁擠的。當空間不足時，支付較高手續費的交易通常會被礦工優先挑選上車，而手續費過低的交易可能會被迫等待很長一段時間。
