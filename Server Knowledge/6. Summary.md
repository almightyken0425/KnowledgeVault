
### 從個人電腦到雲端：現代雲端架構演進之旅 (IaaS vs. PaaS)

在軟體開發中，我們不僅要寫程式，還要想辦法讓程式「跑起來」。這五張圖，正是一部應用程式「如何跑起來」的演進史，核心是「**責任分界線**」的轉移。

我們使用兩種顏色來定義「誰負責管理」：

- **藍色 (Self-Managed)：** 開發者（或公司）必須**自己**負責安裝、設定、維護、更新。
    
- **綠色 (AWS-Managed)：** 雲端服務商 (AWS) 會**自動**幫你管理好一切。

---
#### 第 1 站：一切的起點：本地開發

![本地開發](./assets/local_dev.jpg)

這張圖是所有開發者的起點：在自己的個人電腦 (PC) 上工作。

- **顏色 (全藍色)：** 非常貼切。從實體硬體 (PC)、作業系統 (Windows/Mac)，到安裝 Docker 或 VM，再到應用程式 (App1, App2)，**所有的一切**都需要開發者**自己**負責。
    
- **架構：** 這張圖也展示了在本地端運作的多種方式：
    
    1. **App1/App2 (左側)：** 直接跑在 OS 上，這是最傳統的方式，不同 App 之間可能會有環境衝突。
        
    2. **Docker (中間)：** 使用 Docker Desktop。它在背景偷偷跑了一個 `Mini Linux VM`，來實現 Container 隔離。
        
    3. **VM1 (右側)：** 開發者自己手動建立一台完整的 VM，然後在 VM 裡安裝 Docker。這就像在電腦裡蓋了一間「空房子」。
        

**結論：** 這是最靈活的階段，但也是最繁瑣、最難以規模化的。

---
#### 第 2 站：邁向雲端：IaaS 基礎設施

![IaaS 基礎設施](./assets/iaas_dev.jpg)

當本地電腦不夠用時，第一步就是上雲，租用「**IaaS (基礎設施即服務)**」，代表服務是 AWS EC2。

- **顏色 (綠/藍分明)：** 這是最關鍵的「**責任分界線**」。
    
    - **綠色 (AWS 管理)：** AWS 負責管理實體的 `Hardware` (硬體)、`Hypervisor` (虛擬化技術)。它們提供了一台「**空的 VM (EC2)**」，就像提供一間「**空房子**」。
        
    - **藍色 (自我管理)：** 開發者**必須自己登入**這台 EC2 (空房子)，**自己**負責「**內部裝潢**」：安裝 OS 更新、安裝 `Docker`、部署 `Container` 和 `App`、設定防火牆等。
        
- **架構：** 這就是雲端上最常見的「**VM + 容器**」模式。
    

**結論：** 開發者擺脫了管理「實體硬體」的麻煩，但**仍然需要自己管理「作業系統」和「應用程式」**。

---

#### 第 3 站：專注本業：PaaS 資料庫

![PaaS 資料庫](./assets/paas_database.jpg)

管理資料庫 (DB) 是一件非常複雜的事，包括備份、擴展、主從同步 (Master-Slave)。於是，開發者決定把這件髒活外包出去，採用「**PaaS (平台即服務)**」，代表服務是 AWS RDS。

- **顏色 (全綠色)：** 完美！`Hardware`、`Hypervisor`、`VM`、`DB App (RDS)` **全部都是綠色 (AWS 管理)**。
    
- **責任：** AWS 提供的是「**精裝修且附帶管家**」的服務。開發者**無法（也不需要）**登入底層的 VM 或 OS。
    
- **架構：** 這張圖描繪了 RDS 服務的「**內部運作**」：它是由多台 VM 組成，一台 `Master DB` (負責寫入)，多台 `Slave DB` (負責讀取)，並由 AWS **自動**管理它們之間的 `SYNC` (同步)。
    
- **開發者的工作 (藍色)：** 只有一件事——把「**資料 (Data)**」（圖中 `Master DB` 藍色內核）存進去和讀出來。
    

**結論：** 開發者把「管理資料庫」的繁瑣工作外包給 AWS，自己只管「使用」它。

---

#### 第 4 站：終極進化：PaaS 應用程式

![PaaS 應用程式](./assets/paas_app.jpg)

開發者連管理 EC2 (IaaS) 來跑 App 都覺得累了（例如要自己處理 Auto Scaling），於是決定把 App 也改成「**平台即服務 (PaaS)**」，代表服務就是 AWS Fargate。

- **顏色 (關鍵分界)：**
    
    - **藍色 (開發者責任)：** `Image (Dockerfile + App)`。開發者**唯一**的責任就是寫好 App，並把它打包成一個標準化的「**藍圖 (Image)**」。
        
    - **綠色 (AWS 責任)：** **所有正在運行的實例 (Task)**！
        
- **架構：** AWS Fargate 拿走「藍色」的藍圖，然後**自動**幫你完成**所有**綠色的工作：
    
    1. 啟動 `Hardware` + `Hypervisor`。
        
    2. 啟動 `Mini VM (Firecracker)` 來提供 VM 等級的安全隔離。
        
    3. 在 VM 裡啟動 `Docker` + `Container` + `App1`。
        
    4. 最重要的是，它會**自動「水平擴展 (Scale-Out)」**——也就是圖中「**複製**」好幾份一模一樣的（綠色）運行實例。
        

**結論：** 開發者把「管理應用程式伺服器」的工作也外包給 AWS，自己只管「提供程式碼 (Image)」。

---

### 第 5 站：組裝架構 (關鍵錯誤修正)

最後，這張圖試圖將所有服務組合成一個完整的、可擴展的應用程式架構。

![完整架構](./assets/full_architecture.jpg)

- **組件：**
    
    - `Outside Service` (外部請求)
        
    - `Loading Balance` (負載平衡器 / 交通警察)
        
    - `Container` (Fargate 跑的 App 工人)
        
    - `Master DB / Slave DB` (RDS 提供的資料庫)

1. 請求 (`Outside Service`) 進入 `Load Balancer` (PaaS)。
    
2. `Load Balancer` **「盲目地」**把請求分發給 Fargate `Container1` 或 `Container2` (PaaS)。
    
3. **「聰明才智」**必須寫在 `App1` (藍色 Image) 的**程式碼**裡。
    
4. `Container` 收到請求，`App1` 程式碼**自己判斷**：
    
    - 「這是一個 `Write` (寫入) 請求！」 -> 於是它連線到 `RDS Master Endpoint` (PaaS)。
        
    - 「這是一個 `Read` (讀取) 請求！」 -> 於是它連線到 `RDS Slave Endpoint` (PaaS)。
        
5. `RDS` (PaaS) 在內部自動處理 `Master -> SYNC -> Slave`。
    

---

**總結：** 這一趟旅程，就是從「什麼都自己管」的**本地開發 (全藍色)**，演進到「只管程式碼 (Image) 和資料」的**全雲端 PaaS 架構 (全綠色)** 的過程。

---
