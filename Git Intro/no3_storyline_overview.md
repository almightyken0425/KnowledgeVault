# 版本故事線概覽

這份文件將從最重要的「版本故事線」開始，幫助您建立一個宏觀的視野，理解 Git 的核心操作如何協同工作，來建構一個清晰、可追溯的專案歷史。

---

### 故事線中的關鍵角色

-   **Commit - 存檔點 `C0`, `C1`...:** 專案在某個時間點的快照或存檔點。

-   **Branch - 故事線 `main`, `feature`...:** 一條獨立的開發故事線，永遠指向最新的存檔點。

-   **`commit` - 推進故事線:** 建立一個新的存檔點，並讓目前的故事線向前走一步。

-   **`merge` - 合併故事線:** 將一條故事線的進度，合併到另一條。

-   **Remote - `origin`:** 雲端倉庫的別名，預設叫 `origin`。

-   **`push` - 推送:** 將本地的存檔點，上傳到雲端倉庫。

-   **`pull` / `fetch` - 拉取:** 從雲端倉庫，下載最新的存檔點。

## 版本故事線的全貌 The Big Picture

在使用 Git 時，您所有的操作，最終目的都是在維護一個或多個「版本故事線」。讓我們先看一個完整的故事線是如何從開始、分岔、發展到最終合併的。

### 故事線範例：一個功能的完整生命週期

為了清楚地展示本地與雲端的互動，我們將用兩個圖來分別表示「您的電腦 (Local)」和「GitHub (Remote)」上的故事線狀態。

```
初始狀態：您的本地與雲端倉庫完全同步。

   您的電腦 (Local):
   C0 -- C1 -- C2 (main)

   GitHub (Remote):
   C0 -- C1 -- C2 (main)


本地開發：您建立了一個 'feature' 分支進行開發 (C3, C5)，同時 main 分支也可能因為緊急修復而有了新進度 (C4)。

   您的電腦 (Local):
   C0 -- C1 -- C2 -- C4 (main)
                \
                 C3 -- C5 (feature)

   GitHub (Remote): (尚未收到任何更新，保持原樣)
   C0 -- C1 -- C2 (main)


推送 (`push`)：您將本地的兩條故事線都推送到 GitHub，與團隊分享進度。

   您的電腦 (Local): (狀態不變)
   C0 -- C1 -- C2 -- C4 (main)
                \
                 C3 -- C5 (feature)

   GitHub (Remote): (接收到更新，現在與您的電腦同步)
   C0 -- C1 -- C2 -- C4 (main)
                \
                 C3 -- C5 (feature)


合併 (`merge`)：您的 'feature' 分支開發完成，透過 Pull Request 在 GitHub 上將其合併回 main 分支。

   您的電腦 (Local): (尚未同步，不知道遠端發生了合併)
   C0 -- C1 -- C2 -- C4 (main)
                \
                 C3 -- C5 (feature)

   GitHub (Remote): (main 故事線產生了新的合併節點 C6)
   C0 -- C1 -- C2 -- C4 -- C6 (main)
                \         /
                 C3 -- C5 (feature)


拉取 (`pull`)：您將遠端 main 故事線的最新進度同步回本地。

   您的電腦 (Local): (更新後，main 指標移動到 C6)
   C0 -- C1 -- C2 -- C4 -- C6 (main)
                \         /
                 C3 -- C5 (feature)

   GitHub (Remote): (狀態不變)
   C0 -- C1 -- C2 -- C4 -- C6 (main)
                \         /
                 C3 -- C5 (feature)
```

---

## 常見情境：推送被拒絕 Push Rejection

當您執行 `git push` 時，最常遇到的錯誤就是「推送被拒絕」。這通常不是一個真正的錯誤，而是 Git 的一種保護機制，用來防止您不小心覆蓋掉團隊成員的工作。

### 發生情境：遠端倉庫比你「跑得快」

這個情況最常發生在：當您在本地埋頭工作時，您的同事已經將他的成果 `push` 到遠端的同一個分支上了。

```
初始狀態：您和遠端倉庫都同步在 C2 這個存檔點。

   您的電腦 (Local):   C1 -- C2 (main)
   GitHub (Remote):  C1 -- C2 (main)


同事推送：您的同事完成了 C3，並成功推送到遠端。此刻，遠端倉庫的進度已經超前您。

   您的電腦 (Local):   C1 -- C2 (main)
   GitHub (Remote):  C1 -- C2 -- C3 (main)


您完成工作：您在本地完成了 C4，並準備推送。

   您的電腦 (Local):   C1 -- C2 -- C4 (main)
   GitHub (Remote):  C1 -- C2 -- C3 (main)


推送被拒絕：當您執行 `git push` 時，Git 發現遠端的 `main` (在C3) 和您本地的 `main` (在C4) 已經從 C2 分岔了。如果允許您推送，遠端的 C3 就會被覆蓋掉。因此，Git 拒絕了您的推送，並提示這是一個「非快轉 (non-fast-forward)」更新。
```

### 如何解決？

解決方法很簡單：您需要先將遠端的變更拉取下來，與您本地的變更合併，然後再一起推送上去。

- **拉取並合併 (`git pull`)**: 執行 `git pull`。Git 會將遠端的 C3 下載下來，並自動與您本地的 C4 合併，產生一個新的合併節點 C5。
- **再次推送 (`git push`)**: 現在，您的本地歷史 (`C5`) 完整地包含了遠端的歷史 (`C3`)，您可以成功地執行 `git push` 將所有成果推送到遠端。

### 更佳實踐：使用分支處理遠端變更

直接在 `main` 分支上執行 `git pull` 來解決衝突，會在 `main` 故事線上產生一個合併提交 (merge commit)。當團隊成員頻繁地這樣做時，`main` 分支的歷史會變得複雜且難以追蹤。

更專業的做法是**盡量保持 `main` 故事線的乾淨與線性**。當遇到 `push` 被拒絕時，建議採用以下流程：

```
初始狀態 (推送被拒絕後):

   您的電腦 (Local):   C1 -- C2 -- C4 (main)
   GitHub (Remote):  C1 -- C2 -- C3 (main)
```

- **為您的本地修改建立新分支**：
    ```bash
    # 從您當前的進度 (C4) 建立一個新的分支，例如 my-feature
    git branch my-feature
    ```
    此操作會為您當前的進度 (C4) 建立一個名為 `my-feature` 的新分支指標，將您的本地修改隔離出來。
    ```
    您的電腦 (Local):
    C1 -- C2 -- C4 (main, my-feature)
    ```

- **更新並清理本地 `main` 分支**：
    ```bash
    # 切換回 main 分支
    git checkout main
    # 拉取遠端最新進度，並使用 rebase 模式來保持歷史線性 (此處效果等同於 git reset --hard origin/main)
    git pull --rebase
    ```
    執行後，本地的 `main` 分支會與遠端的 `main` 完全同步 (`C1-C2-C3`)，而您自己的修改 `C4` 則被安全地保留在 `my-feature` 分支上。
    ```
    您的電腦 (Local):
                 C4 (my-feature)
                /
    C1 -- C2 -- C3 (main)
    ```

- **重新應用您的變更**：
    此時，您可以從一個乾淨的 `main` 分支基礎上，選擇將 `my-feature` 的變更合併回來，或是將 `my-feature` 推送到遠端並發起一個 Pull Request。例如，使用 `rebase` 將您的變更疊加到最新的 `main` 之上：
    ```bash
    # 切換到您的功能分支
    git checkout my-feature
    # 將 my-feature 的變更，重新在最新的 main (C3) 上播放一次
    git rebase main
    ```
    執行後，Git 會建立一個新的存檔點 `C4'`，它包含了 `C4` 的所有修改，但基底是 `C3` 而不是 `C2`。
    ```
    您的電腦 (Local):
    C1 -- C2 -- C3 (main) -- C4' (my-feature)
    ```
    現在，您的 `my-feature` 分支既包含了遠端的最新進度，也包含了您自己的修改，並且歷史紀錄是線性的。您可以安全地將 `main` 分支快轉到 `C4'`，然後一次性推送到遠端。

這個流程的核心思想是：**避免在 `main` 分支上直接解決衝突。應先將自己的修改移至一個臨時分支，讓 `main` 與遠端同步後，再處理自己的修改。** 這也是為什麼在團隊協作中，強烈建議所有新工作都在獨立的分支上進行的原因。

---
